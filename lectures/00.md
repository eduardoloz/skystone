# 00-lecture Wednesday, November 6, 2019
## What is computer science? 
- The study of computers, their design (architecture), and their uses for computation, data processing, and systems control, including design and development of hardware, software, and programming 
- The field encompasses theory, mathematical activities such as design and analysis of algorithms, performance studies of systems and their components, and estimation of reliability and availability of systems by probabilistic techniques. 
- Because computer systems are often too large and complicated, failure or success of a design to be predicted without testing, experimentation is built into the development cycle.

## How does the definition of computer science apply to robotics?
- We are focusing on systems control, design and analysis of algorithms, and experimentation 
- Product management 

## Notes on Feedback
- Most are freshmen
- Most donâ€™t have experience with programming
- Most are interested in website development and robot programming 
  - Website development is under the marketing department this year but as noted in previous lectures, FTC is more flexible in terms of what you want to do. 
- There is only so much space for everyone to do development on programming 
  - What you get out of this experience will be equal to how many questions you ask, how much you want to learn, how much you put in

## Preliminary Assignment 
- Go to https://github.com/fusion479/skystone and complete the tasks in the README. 
- Due date: whenever you want

## Java Overview
- Java is an object-oriented programming (and I OOP) language 
- Compiled language 
  - write in English, compiler stage by Java virtual machine (JVM) to turn into bytecode that a computer can execute 
- What version of Java are we going to use? 
  - to be decided, instructions on how to download to follow on GitHub README
- Object-oriented means that programs that you write will be in the context of an object
  - Objects (classes) have properties (fields) and actions (methods) 
  - In robotics, there will generally be two kinds of objects: hardware, and operational modes. 
    - Think of operational mode objects as users of objects 
    
### EXAMPLE
```
    //HARDWARE 
    define Phone:
    
        contructor(parameters parameters):
            // a constructor makes a new phone 
        
        properties(fields): //more generally, fields can also be things that an objects has, not just attributes
            Facebook facebook // type name
            YouTube youtube 
            Camera camera 
            Browser browser  
            number time;
            number battery; 
            number sim_card;
            
            //Apps are other objects that have been previously defined
            //numbers are primitive values, they are not defined in other files
           
        actions(methods):
            turnOnPhone()
            turnOffPhone()
            open(App app): //note the parameters 
                app.open() //maybe in the app object, there is another method called open
            close(App app):
   
   define App:
        properties of an app
        things an app can do
        
   define Facebook inherits from App: //app is a superclass, think of App as a general definition of an app
        Facebook can do whatever Apps can do, but they might also have more specified properties and actions 
        like
        comment
        post 
       
    //USERS
    define Person:
        // person has to get a new phone 
        Phone phone = new Phone(); //this calls the constructor of Phone
        //some other properties a person has 
            
        main(): // in java there is a main method that will be invoked whenever the program is started. 
                // we don't use the main method in java but we use something equivalent 
            //this method will house the routine that we want the person to follow
            phone.turnOnPhone()
            phone.openApp(youtube)
            phone.turnOffPhone()
```

### Activity (10 minutes)
- Lets develop hardware and user definitions for our robot, and userofrobot in the context of the skystone game 
- first review objectives 


References (make this simple!)

Booleans and If statements
maybe mention steps and shit

Iteration (for loops, while loops)
touch on recursion

Short overview of Classes

- Here is a more concrete and syntactically sound version of something we just did
```Java

// imports and packages are essentially files that were previously written by the cool people at FIRST
// we don't want to reinvent the wheel everytime; they provide objects for us 
package org.firstinspires.ftc.teamcode.hardware;

import com.qualcomm.hardware.bosch.BNO055IMU;
import com.qualcomm.hardware.bosch.JustLoggingAccelerationIntegrator;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.hardware.DcMotor;
import com.qualcomm.robotcore.hardware.DcMotorSimple;
import com.qualcomm.robotcore.hardware.HardwareMap;
import com.qualcomm.robotcore.util.Range;
import org.firstinspires.ftc.teamcode.PIDController;

import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;
import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;
import org.firstinspires.ftc.robotcore.external.navigation.Orientation;
import org.firstinspires.ftc.teamcode.hardware.Mechanism;

// public means that this class object can be accessed from other files
// it is accessed in our DriveTest file 
// our DriveTrain is a Mechanism
// all mechanisms have an operational mode context and a initilization function to initialize the mechanism 

public class Drivetrain extends Mechanism {
    private static final double     COUNTS_PER_MOTOR_REV    = 1120;
    
    //private means that this property cannot be accessed from other files 
    //static means that the value is the same from object to object
    //final means that the varialbe value cannot change
    //double is a floating point number 

    /**
     * Drivetrain gear ratio (< 1.0 if geared up).
     */
    private static final double     DRIVE_GEAR_REDUCTION    = 1.0;

    /**
     * Diameter of wheel in inches.
     */
    private static final double     WHEEL_DIAMETER_INCHES   = 4.0;

    /**
     * Calculated ticks per inch.
     */
    private static final double     COUNTS_PER_INCH         =
            (COUNTS_PER_MOTOR_REV * DRIVE_GEAR_REDUCTION) / (WHEEL_DIAMETER_INCHES * 3.1415);

    private DcMotor frontLeft;
    private DcMotor frontRight;
    private DcMotor backLeft;
    private DcMotor backRight;
    public BNO055IMU imu;
    private PIDController pidDrive;
    private PIDController pidRotate;

    double  globalAngle, power = .30, correction;
    Orientation lastAngles = new Orientation();

    private double flPower = 0.0, frPower = 0.0, blPower = 0.0, brPower = 0.0;

    public Drivetrain() {
    }

    public Drivetrain(LinearOpMode opMode) {
        this.opMode = opMode;
    }

    public void init(HardwareMap hwMap) {
        frontLeft = hwMap.dcMotor.get("frontLeft");
        frontRight = hwMap.dcMotor.get("frontRight");
        backLeft = hwMap.dcMotor.get("backLeft");
        backRight = hwMap.dcMotor.get("backRight");

        // Set motor direction (AndyMark configuration)
        frontLeft.setDirection(DcMotorSimple.Direction.FORWARD);
        backLeft.setDirection(DcMotorSimple.Direction.FORWARD);
        frontRight.setDirection(DcMotorSimple.Direction.REVERSE);
        backRight.setDirection(DcMotorSimple.Direction.REVERSE);

        // Set motor brake behavior
        frontLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        frontRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        backLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);
        backRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);

        pidRotate = new PIDController(0.005, 0.1, 0);
        pidDrive = new PIDController(0.05,0,0);

        // Set all motors to zero power
        setPower(0.0);

        // Initialize IMU with parameters
        BNO055IMU.Parameters parameters = new BNO055IMU.Parameters();
        parameters.angleUnit           = BNO055IMU.AngleUnit.DEGREES;
        parameters.accelUnit           = BNO055IMU.AccelUnit.METERS_PERSEC_PERSEC;
//        parameters.calibrationDataFile = "BNO055IMUCalibration.json"; // see the calibration sample opmode
        parameters.loggingEnabled      = false;
        parameters.loggingTag          = "IMU";
        parameters.accelerationIntegrationAlgorithm = new JustLoggingAccelerationIntegrator();

        // Retrieve and initialize the IMU
        imu = hwMap.get(BNO055IMU.class, "imu");
        imu.initialize(parameters);
    }

    public void teleDrive(double r, double robotAngle, double rightX) {
        double v1 = r * Math.sin(robotAngle) - rightX;
        double v2 = r * Math.cos(robotAngle) + rightX;
        double v3 = r * Math.cos(robotAngle) - rightX;
        double v4 = r * Math.sin(robotAngle) + rightX;
        setPower(v1,v2,v3,v4);
    }

    public double trueScaledInput(double joystickValue){
        double signum = Math.signum(joystickValue);
        double joystickScale = Math.pow(joystickValue,2) * signum;
        return joystickScale;
    }

    public void tankDriveScaled(double leftY, double rightY, double slide){
        flPower = trueScaledInput(leftY) - trueScaledInput(slide);
        frPower = trueScaledInput(rightY) + trueScaledInput(slide);
        blPower = trueScaledInput(leftY) + trueScaledInput(slide);
        brPower = trueScaledInput(rightY) - trueScaledInput(slide);

        frontLeft.setPower(Range.clip(flPower,-1,1));
        backLeft.setPower(Range.clip(blPower,-1,1));
        backRight.setPower(Range.clip(brPower,-1,1));
        frontRight.setPower(Range.clip(frPower,-1,1));
    }

    public void driveToPos(double inches, double power) {
        frontLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        backLeft.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        backRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);
        frontRight.setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);

        int tickCount = (int) (inches * COUNTS_PER_INCH);
        double set_power = power*inches/Math.abs(inches);

        frontLeft.setTargetPosition(tickCount);
        backLeft.setTargetPosition(tickCount);
        backRight.setTargetPosition(tickCount);
        frontRight.setTargetPosition(tickCount);

        frontLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        backLeft.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        frontRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);
        backRight.setMode(DcMotor.RunMode.RUN_TO_POSITION);

        while(opMode.opModeIsActive() && frontLeft.isBusy() && frontRight.isBusy() && backLeft.isBusy() && backRight.isBusy()) {
            setPower(set_power);
        }

        setPower(0.0);
    }

    private void setPower(double power) {
        setPower(power, power, power, power);
    }

    public void setPower(double FL, double FR, double BL, double BR) {
        frontLeft.setPower(FL);
        backRight.setPower(BR);
        backLeft.setPower(BL);
        frontRight.setPower(FR);
    }

    /**
     * Resets the cumulative angle tracking to zero.
     */
    public void resetAngle()
    {
        lastAngles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);

        globalAngle = 0;
    }

    public float getHeading() {
        return lastAngles.firstAngle;
    }

    public double getGlobal() {
        return globalAngle;
    }

    /**
     * Get current cumulative angle rotation from last reset.
     * @return Angle in degrees. + = left, - = right from zero point.
     */
    public double getAngle()
    {
        // We experimentally determined the Z axis is the axis we want to use for heading angle.
        // We have to process the angle because the imu works in euler angles so the Z axis is
        // returned as 0 to +180 or 0 to -180 rolling back to -179 or +179 when rotation passes
        // 180 degrees. We detect this transition and track the total cumulative angle of rotation.

        Orientation angles = imu.getAngularOrientation(AxesReference.INTRINSIC, AxesOrder.ZYX, AngleUnit.DEGREES);

        double deltaAngle = angles.firstAngle - lastAngles.firstAngle;

        if (deltaAngle < -180)
            deltaAngle += 360;
        else if (deltaAngle > 180)
            deltaAngle -= 360;

        globalAngle += deltaAngle;

        lastAngles = angles;

        return globalAngle;
    }

    /**
     * Rotate left or right the number of degrees. Does not support turning more than 180 degrees.
     * @param degrees Degrees to turn, + is left - is right
     */
    public void turn(int degrees, double power) {
        // restart imu angle tracking.
        resetAngle();
        double p = Math.abs(power/degrees);
        double i = p / 115.0;
        pidRotate.setPID(p, i, 0);

        pidRotate.setSetpoint(degrees);
        pidRotate.setInputRange(0, degrees);
        pidRotate.setOutputRange(0, power);
        pidRotate.setTolerance(1.0 / Math.abs(degrees) * 115.0);
        pidRotate.enable();
        if (degrees < 0) {
            while (getAngle() == 0) {
                frontLeft.setPower(-power);
                backLeft.setPower(-power);
                frontRight.setPower(power);
                backRight.setPower(power);
            }
            do {
                power = pidRotate.performPID(getAngle()); // power will be - on right turn.
                frontLeft.setPower(power);
                backLeft.setPower(power);
                frontRight.setPower(-power);
                backRight.setPower(-power);
            }
            while (!pidRotate.onTarget());
        }
        else    // left turn.
            do {
                power = pidRotate.performPID(getAngle()); // power will be + on left turn.
                frontLeft.setPower(power);
                backLeft.setPower(power);
                frontRight.setPower(-power);
                backRight.setPower(-power);
            }
            while (!pidRotate.onTarget());

        // turn the motors off.
        frontLeft.setPower(0);
        backLeft.setPower(0);
        frontRight.setPower(0);
        backRight.setPower(0);
        resetAngle();
    }
}
```

Autonomous routine 
```Java
package org.firstinspires.ftc.teamcode.opmode.auton;

import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.util.ElapsedTime;

import org.firstinspires.ftc.robotcore.external.navigation.AngleUnit;
import org.firstinspires.ftc.robotcore.external.navigation.AxesOrder;
import org.firstinspires.ftc.robotcore.external.navigation.AxesReference;
import org.firstinspires.ftc.robotcore.external.navigation.Orientation;
import org.firstinspires.ftc.teamcode.hardware.Drivetrain;

@Autonomous(name = "Basic")
public class Basic extends LinearOpMode {
    private ElapsedTime     runtime = new ElapsedTime();
    Drivetrain drivetrain = new Drivetrain(this);

    public void runOpMode() {

        drivetrain.init(hardwareMap);
        telemetry.addData("Status", "Initialized");
        telemetry.addData("imu status", drivetrain.imu.getCalibrationStatus().toString());
        drivetrain.getAngle();
        telemetry.update();
        waitForStart();
        runtime.reset();  // Start counting run time from now.
        drivetrain.resetAngle();
//        drivetrain.driveToPos(5, 0.5);
//        drivetrain.setPower(0.5,-0.5,0.5,-0.5);
//        sleep(10000);
//        drivetrain.setPower(0,0,0,0);
//
        while(opModeIsActive()) {
            drivetrain.turn(-120,0.7);
            sleep(1000);
            drivetrain.turn(120,0.7);
            sleep(1000);
            drivetrain.driveToPos(5,0.75);
//            telemetry.addData("1 imu heading", drivetrain.getHeading());
//            telemetry.addData("2 global heading", drivetrain.getHeading());
//            telemetry.update();
//            drivetrain.getAngle();
            break;
        }

//        drivetrain.turn(90,0.5);

    }
}

```

Teleoperational routine
```Java
package org.firstinspires.ftc.teamcode.opmode.teleop;

import com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;
import com.qualcomm.robotcore.eventloop.opmode.TeleOp;
import com.qualcomm.robotcore.hardware.Gamepad;
import org.firstinspires.ftc.teamcode.hardware.Drivetrain;
import org.firstinspires.ftc.teamcode.hardware.Launcher;


@TeleOp(name="Drive", group="Teleop")
public class DriveTest extends LinearOpMode {

    double leftInput, rightInput, slideInput, launchInput;

    private Drivetrain drive = new Drivetrain();
//    private Launcher launcher = new Launcher();

    @Override
    public void runOpMode() throws InterruptedException {
        drive.init(hardwareMap);
//        launcher.init(hardwareMap);

        while(!opModeIsActive() && !isStopRequested()) {
            telemetry.addData("Status", "Waiting in Init");
            telemetry.update();
        }

        waitForStart();

        while(opModeIsActive()) {
            double r = Math.hypot(gamepad1.left_stick_x, gamepad1.left_stick_y);
            double robotAngle = Math.atan2(gamepad1.left_stick_y, gamepad1.left_stick_x) - Math.PI / 4;
            double rightX = gamepad1.right_stick_x;

            drive.teleDrive(r, robotAngle, rightX);

            if(gamepad1.left_trigger > 0) {
//                launcher.launch(-gamepad1.left_trigger);
            }
            else if (gamepad1.right_trigger > 0) {
//                launcher.launch(gamepad1.right_trigger);
            }
            else if (gamepad1.left_trigger == 0 && gamepad1.right_trigger == 0) {
//                launcher.launch(0);
            }

            telemetry.addData("r", r);
            telemetry.addData("robotAngle", robotAngle);
            telemetry.addData("rightX", rightX);

            telemetry.addData("stickx", gamepad1.right_stick_x);
            telemetry.addData("sticky", gamepad1.right_stick_y);
            telemetry.update();
//            leftInput = gamepad1.left_stick_y;
//            rightInput = gamepad1.right_stick_y;
//            slideInput = -gamepad1.left_trigger + gamepad1.right_trigger;

//            drive.tankDriveScaled(leftInput, rightInput, slideInput);
        }
    }
}
```
